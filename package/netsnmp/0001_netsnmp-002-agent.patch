--- netsnmp-5.4.2.1_orig/agent/agent_trap.c.orig	2022-05-26 14:33:57.975843799 +0300
+++ netsnmp-5.4.2.1_new/agent/agent_trap.c	2012-09-09 12:43:33.886695990 +0300
@@ -62,6 +62,12 @@
 #include <net-snmp/agent/agent_trap.h>
 #include <net-snmp/agent/snmp_agent.h>
 #include <net-snmp/agent/agent_callbacks.h>
+// Alan add
+#include <net-snmp/agent/agent_handler.h>
+#include <net-snmp/library/snmp_api.h>
+#include <net-snmp/library/snmp_client.h>
+#include <net-snmp/library/fd_event_manager.h>
+// End Alan add
 #include "agent_global_vars.h"
 
 #include <net-snmp/agent/agent_module_config.h>
@@ -88,6 +94,7 @@
     struct trap_sink *next;
     int             pdutype;
     int             version;
+	u_char			my_data[60]; // Alan add
 };
 
 struct trap_sink *sinks = NULL;
@@ -145,6 +152,29 @@
 	 * Trap session handling
 	 *
 	 *******************/
+// Alan add
+int GetNumOfSinks( void)
+{
+    struct trap_sink *sink;
+	int numOf = 0;
+    for (sink = sinks; sink; sink = sink->next)
+		numOf ++;
+	return numOf;
+}
+
+
+void AddMyDataToLastSink( void * srcP, int srcLen)
+{
+	if(srcLen < sizeof(sinks->my_data))
+		memcpy( sinks->my_data, srcP, srcLen);
+}
+
+volatile int (* myBeforeSendTrapPtr)( void * my_data, netsnmp_session * sessionP, netsnmp_pdu *template_pdu) = NULL;
+
+volatile oid myEnterpriseOid[50];
+volatile int myEnterpriseOidLen = 0;
+
+// End Alan add
 
 void
 init_traps(void)
@@ -835,6 +865,12 @@
     in_addr_t             *pdu_in_addr_t;
     u_long                 uptime;
     struct trap_sink *sink;
+
+// Alan add
+	enterprise = myEnterpriseOid;
+	enterprise_length = myEnterpriseOidLen;
+// End Alan add
+
     const char            *v1trapaddress;
     int                    res = 0;
 
@@ -1025,13 +1061,30 @@
             if (template_v1pdu &&
                 !netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,
                                         NETSNMP_DS_LIB_DISABLE_V1)) {
-                send_trap_to_sess(sink->sesp, template_v1pdu);
+// Alan add
+			    int toDo = 1;
+			    if(myBeforeSendTrapPtr != NULL)
+			    	toDo = myBeforeSendTrapPtr( sink->my_data, sink->sesp, template_v1pdu);
+
+			    if(toDo != 0)
+                	send_trap_to_sess(sink->sesp, template_v1pdu);
+// End Alan add
+                //send_trap_to_sess(sink->sesp, template_v1pdu); // Alan remove
             }
         } else
 #endif
         if (template_v2pdu) {
             template_v2pdu->command = sink->pdutype;
-            send_trap_to_sess(sink->sesp, template_v2pdu);
+// Alan add
+
+			    int toDo = 1;
+			    if(myBeforeSendTrapPtr != NULL)
+			    	toDo = myBeforeSendTrapPtr( sink->my_data, sink->sesp, template_v2pdu);
+
+			    if(toDo != 0)
+	                send_trap_to_sess(sink->sesp, template_v2pdu);
+// End Alan add
+            // send_trap_to_sess(sink->sesp, template_v2pdu); // Alan remove
         }
     }
 #ifndef NETSNMP_DISABLE_SNMPV1
--- netsnmp-5.4.2.1_orig/agent/snmpd.c.orig	2008-08-17 23:50:55.000000000 +0300
+++ netsnmp-5.4.2.1_new/agent/snmpd.c	2012-09-09 12:41:15.250695993 +0300
@@ -405,6 +405,14 @@
     FILE           *PID;
 #endif
 
+// Alan add
+    /* !!! DO NOT DELETE THE FOLLOWING 2 LINES !!! */ 
+    extern GetNumOfSinks(), AddMyDataToLastSink();
+    printf("%p %p %p %p %p %p %p %p\n", GetNumOfSinks, AddMyDataToLastSink,
+    		snmp_add_var, netsnmp_unregister_handler,
+    		snmp_unregister_callback, snmp_set_var_typed_integer,
+		register_readfd, unregister_readfd);
+// End Alan add
     SOCK_STARTUP;
 
 #ifndef NETSNMP_NO_SYSTEMD
