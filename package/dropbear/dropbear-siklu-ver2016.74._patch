diff -uNr -x '*.log' -x '*.sta*' -x '.p*' -x 'Makefile*' dropbear-2016.74.orig/cli-kex.c dropbear-2016.74.new/cli-kex.c
--- dropbear-2016.74.orig/cli-kex.c	2016-07-21 18:17:09.000000000 +0300
+++ dropbear-2016.74.new/cli-kex.c	2017-02-14 15:33:50.000000000 +0200
@@ -228,7 +228,7 @@
 
 	if (!homedir) {
 		struct passwd * pw = NULL;
-		pw = getpwuid(getuid());
+		pw = _getpwuid(getuid()); // Siklu
 		if (pw) {
 			homedir = pw->pw_dir;
 		}
diff -uNr -x '*.log' -x '*.sta*' -x '.p*' -x 'Makefile*' dropbear-2016.74.orig/cli-runopts.c dropbear-2016.74.new/cli-runopts.c
--- dropbear-2016.74.orig/cli-runopts.c	2016-07-21 18:17:09.000000000 +0300
+++ dropbear-2016.74.new/cli-runopts.c	2017-02-14 15:34:33.000000000 +0200
@@ -718,7 +718,7 @@
 
 	uid = getuid();
 
-	pw = getpwuid(uid);
+	pw = _getpwuid(uid); // Siklu
 	if (pw && pw->pw_name != NULL) {
 		cli_opts.own_user = m_strdup(pw->pw_name);
 	} else {
diff -uNr -x '*.log' -x '*.sta*' -x '.p*' -x 'Makefile*' dropbear-2016.74.orig/common-session.c dropbear-2016.74.new/common-session.c
--- dropbear-2016.74.orig/common-session.c	2016-07-21 18:17:09.000000000 +0300
+++ dropbear-2016.74.new/common-session.c	2017-02-14 15:26:52.000000000 +0200
@@ -594,7 +594,7 @@
 	if (ses.authstate.pw_passwd)
 		m_free(ses.authstate.pw_passwd);
 
-	pw = getpwnam(username);
+	pw = _getpwnam(username); // Siklu
 	if (!pw) {
 		return;
 	}
diff -uNr -x '*.log' -x '*.sta*' -x '.p*' -x 'Makefile*' dropbear-2016.74.orig/dbutil.c dropbear-2016.74.new/dbutil.c
--- dropbear-2016.74.orig/dbutil.c	2016-07-21 18:17:09.000000000 +0300
+++ dropbear-2016.74.new/dbutil.c	2017-02-14 15:54:58.000000000 +0200
@@ -603,7 +603,7 @@
 char * expand_homedir_path(const char *inpath) {
 	struct passwd *pw = NULL;
 	if (inpath[0] != '/') {
-		pw = getpwuid(getuid());
+		pw = _getpwuid(getuid()); // Siklu
 		if (pw && pw->pw_dir) {
 			int len = strlen(inpath) + strlen(pw->pw_dir) + 2;
 			char *buf = m_malloc(len);
diff -uNr -x '*.log' -x '*.sta*' -x '.p*' -x 'Makefile*' dropbear-2016.74.orig/dropbearkey.c dropbear-2016.74.new/dropbearkey.c
--- dropbear-2016.74.orig/dropbearkey.c	2016-07-21 18:17:09.000000000 +0300
+++ dropbear-2016.74.new/dropbearkey.c	2017-02-14 15:35:40.000000000 +0200
@@ -325,7 +325,7 @@
 
 	/* a user@host comment is informative */
 	username = "";
-	pw = getpwuid(getuid());
+	pw = _getpwuid(getuid()); // Siklu
 	if (pw) {
 		username = pw->pw_name;
 	}
diff -uNr -x '*.log' -x '*.sta*' -x '.p*' -x 'Makefile*' dropbear-2016.74.orig/includes.h dropbear-2016.74.new/includes.h
--- dropbear-2016.74.orig/includes.h	2016-07-21 18:17:09.000000000 +0300
+++ dropbear-2016.74.new/includes.h	2017-02-14 15:37:45.000000000 +0200
@@ -57,6 +57,7 @@
 #include <stdarg.h>
 #include <dirent.h>
 #include <time.h>
+#include "siklu_pwd.h"   // Siklu
 
 #ifdef HAVE_UTMP_H
 #include <utmp.h>
diff -uNr -x '*.log' -x '*.sta*' -x '.p*' -x 'Makefile*' dropbear-2016.74.orig/loginrec.c dropbear-2016.74.new/loginrec.c
--- dropbear-2016.74.orig/loginrec.c	2016-07-21 18:17:09.000000000 +0300
+++ dropbear-2016.74.new/loginrec.c	2017-02-14 15:27:46.000000000 +0200
@@ -275,7 +275,7 @@
 
 	if (username) {
 		strlcpy(li->username, username, sizeof(li->username));
-		pw = getpwnam(li->username);
+		pw = _getpwnam(li->username); // Siklu
 		if (pw == NULL)
 			dropbear_exit("login_init_entry: Cannot find user \"%s\"",
 					li->username);
diff -uNr -x '*.log' -x '*.sta*' -x '.p*' -x 'Makefile*' dropbear-2016.74.orig/options.h dropbear-2016.74.new/options.h
--- dropbear-2016.74.orig/options.h	2016-07-21 18:17:09.000000000 +0300
+++ dropbear-2016.74.new/options.h	2017-02-14 15:41:46.000000000 +0200
@@ -213,10 +213,10 @@
 
 /* This requires crypt() */
 #ifdef HAVE_CRYPT
-#define ENABLE_SVR_PASSWORD_AUTH
+// #define ENABLE_SVR_PASSWORD_AUTH   Siklu commented
 #endif
 /* PAM requires ./configure --enable-pam */
-/*#define ENABLE_SVR_PAM_AUTH */
+#define ENABLE_SVR_PAM_AUTH  // Siklu opened
 #define ENABLE_SVR_PUBKEY_AUTH
 
 /* Whether to take public key options in 
diff -uNr -x '*.log' -x '*.sta*' -x '.p*' -x 'Makefile*' dropbear-2016.74.orig/siklu_dropbear.c dropbear-2016.74.new/siklu_dropbear.c
--- dropbear-2016.74.orig/siklu_dropbear.c	1970-01-01 02:00:00.000000000 +0200
+++ dropbear-2016.74.new/siklu_dropbear.c	2016-10-05 18:05:32.000000000 +0300
@@ -0,0 +1,153 @@
+/*
+ * siklu_dropbear.c
+ *
+ *  Created on: Jun 26, 2014
+ *      Author: edwardk
+ *
+ *
+ Follow method operates on original /etc/passwd and /etc/shadow files
+ siklu_getpwnam_passwd_file(name). It works.
+ *
+
+ *
+ */
+
+#include "includes.h"
+#include "session.h"
+#include "dbutil.h"
+#include "packet.h"
+#include "algo.h"
+#include "buffer.h"
+#include "dss.h"
+#include "ssh.h"
+
+#include <stddef.h>
+#include <sys/types.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <pwd.h>
+#include <syslog.h>
+#include <unistd.h>
+#include <time.h>
+
+// #define PAM_DEBUG
+#undef PAM_DEBUG
+
+#ifdef PAM_DEBUG
+# define debugp syslog
+#else
+# define debugp(fmt, a...)
+#endif
+
+#define MAX_TEMP_BUFFER		128
+#define MAX_CRYPTED_PASS	128
+
+typedef enum { // declares linux groups. see /etc/groups file
+	E_USER_TYPE_DEBUG = 0, /* This is real superuser (root) */
+	E_USER_TYPE_USER = 1000,
+	E_USER_TYPE_TECH,
+	E_USER_TYPE_SUPER,
+	E_USER_TYPE_ADMIN = 1100,
+	E_USER_TYPE_REMOTE_AUTH = 1200,
+// tacacs AAA user
+} T_USER_TYPE; // copied from CaExternal.h
+
+static int pw_uid = 800; // base for all new user's ID
+
+static int PAM_GenerateRandomUserPassword(int passw_len, char* passw) //
+{
+	int i;
+
+	static const char alphanum[] = "0123456789"
+			"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+			"abcdefghijklmnopqrstuvwxyz";
+	srand(time(NULL));
+	for (i = 0; i < passw_len; ++i) //
+			{
+		passw[i] = alphanum[rand() % (sizeof(alphanum) - 1)];
+	}
+
+	passw[passw_len] = 0;
+	debugp(LOG_NOTICE, "%s() Generated passw %s\n", __func__, passw);
+	return 0;
+
+}
+
+#define   MAX_USER_PASS	16
+
+/*
+ * Check if user already defined in process environment area
+ * 		if yes, fill passwd struct by user parameters
+ * 		if not generate user params in an environment
+ *
+ *
+ *
+ */
+static struct passwd *siklu_getpwnam_virtual_user(const char *name) //
+{
+	static struct passwd ret;
+	char temp[MAX_USER_PASS];
+	char* env_user_name = getenv("V_USER");
+	if (env_user_name == NULL) {
+		// generate environment variables
+
+		PAM_GenerateRandomUserPassword(MAX_USER_PASS - 1, temp);
+		setenv("V_USER", name, 1);
+		setenv("V_PASSWD", temp, 1);
+		setenv("V_DIR", "/home/sw", 1);
+		setenv("V_SHELL", "/home/sw/bin/cli", 1);
+
+	}
+
+	ret.pw_name = getenv("V_USER");
+	ret.pw_passwd = getenv("V_PASSWD");
+	ret.pw_uid = 900;
+
+	ret.pw_gid = E_USER_TYPE_REMOTE_AUTH;
+	ret.pw_gecos = getenv("V_USER");
+	ret.pw_dir = getenv("V_DIR");
+	ret.pw_shell = getenv("V_SHELL");
+
+	return (struct passwd *) &ret;
+
+}
+
+// ====================   Global functions ==================================
+
+struct passwd *_getpwnam(const char *name) {
+	struct passwd *ret = NULL;
+
+	ret = getpwnam(name);
+	debugp(LOG_NOTICE, "%s() called for user %s, ret val %p, process ID %d",
+			__func__, name, ret, getpid());
+	if (ret != NULL) { // user registered in /etc/passwd
+		debugp(LOG_NOTICE, " User \"%s\" exists in /etc/passwd", name);
+	} else {
+		debugp(LOG_NOTICE, " Add User %s to a system", name);
+		ret = siklu_getpwnam_virtual_user(name); // (see remarks in file header)
+	} //
+	debugp(LOG_NOTICE, "pw_name \"%s\", pw_passwd \"%s\", pw_uid %d, pw_gid %d",
+			ret->pw_name, ret->pw_passwd, ret->pw_uid, ret->pw_gid);debugp(LOG_NOTICE, "pw_gecos \"%s\", pw_dir \"%s\", pw_shell \"%s\"",
+			ret->pw_gecos, ret->pw_dir, ret->pw_shell);
+	return ret;
+}
+
+/*
+ *
+ *
+ */
+struct passwd *_getpwuid(uid_t uid) {
+	struct passwd *ret;
+	ret = getpwuid(uid);
+
+	if (uid != 0) {// the function called by scp request. only root allowed execute it
+		syslog(LOG_ERR, "%s   %s() The function should not be called! uid %d, ret %p", __FILE__, __func__, uid, ret);
+	}
+	if (ret != NULL) { // edikk remove after debug
+		debugp(LOG_NOTICE, "pw_name %s, pw_passwd %s, pw_uid %d, pw_gid %d",
+				ret->pw_name, ret->pw_passwd, ret->pw_uid, ret->pw_gid);debugp(LOG_NOTICE, "pw_gecos %s, pw_dir %s, pw_shell %s", ret->pw_gecos,
+				ret->pw_dir, ret->pw_shell);
+	}
+	return ret;
+}
diff -uNr -x '*.log' -x '*.sta*' -x '.p*' -x 'Makefile*' dropbear-2016.74.orig/siklu_pwd.h dropbear-2016.74.new/siklu_pwd.h
--- dropbear-2016.74.orig/siklu_pwd.h	1970-01-01 02:00:00.000000000 +0200
+++ dropbear-2016.74.new/siklu_pwd.h	2016-10-05 18:05:32.000000000 +0300
@@ -0,0 +1,31 @@
+/*
+ * siklu_pwd.h
+ *
+ *  Created on: Jun 26, 2014
+ *      Author: edwardk
+ */
+
+#ifndef SIKLU_PWD_H_
+#define SIKLU_PWD_H_
+
+
+/*
+ * struct passwd {
+		 char   *pw_name;       / * username * /
+		 char   *pw_passwd;     / * user password * /
+		 uid_t   pw_uid;        / * user ID * /
+		 gid_t   pw_gid;        / * group ID * /
+		 char   *pw_gecos;      / * user information * /
+		 char   *pw_dir;        / * home directory * /
+		 char   *pw_shell;      / * shell program * /
+		 };
+*/
+
+
+extern struct passwd *_getpwnam(const char *name);
+
+extern struct passwd *_getpwuid(uid_t uid);
+
+
+
+#endif /* SIKLU_PWD_H_ */
diff -uNr -x '*.log' -x '*.sta*' -x '.p*' -x 'Makefile*' dropbear-2016.74.orig/svr-authpam.c dropbear-2016.74.new/svr-authpam.c
--- dropbear-2016.74.orig/svr-authpam.c	2016-07-21 18:17:09.000000000 +0300
+++ dropbear-2016.74.new/svr-authpam.c	2017-02-14 15:48:05.000000000 +0200
@@ -232,9 +232,10 @@
 	/* (void) pam_set_item(pamHandlep, PAM_FAIL_DELAY, (void*) pamDelayFunc); */
 
 	if ((rc = pam_authenticate(pamHandlep, 0)) != PAM_SUCCESS) {
-		dropbear_log(LOG_WARNING, "pam_authenticate() failed, rc=%d, %s", 
+		// Siklu In log below LOG_WARNING replaced by LOG_NOTICE
+		dropbear_log(LOG_NOTICE, "pam_authenticate() failed, rc=%d, %s", 
 				rc, pam_strerror(pamHandlep, rc));
-		dropbear_log(LOG_WARNING,
+		dropbear_log(LOG_NOTICE,
 				"Bad PAM password attempt for '%s' from %s",
 				ses.authstate.pw_name,
 				svr_ses.addrstring);
@@ -243,15 +244,38 @@
 	}
 
 	if ((rc = pam_acct_mgmt(pamHandlep, 0)) != PAM_SUCCESS) {
-		dropbear_log(LOG_WARNING, "pam_acct_mgmt() failed, rc=%d, %s", 
+		// Siklu In log below LOG_WARNING replaced by LOG_NOTICE
+		dropbear_log(LOG_NOTICE, "pam_acct_mgmt() failed, rc=%d, %s", 
 				rc, pam_strerror(pamHandlep, rc));
-		dropbear_log(LOG_WARNING,
+		dropbear_log(LOG_NOTICE,
 				"Bad PAM password attempt for '%s' from %s",
 				ses.authstate.pw_name,
 				svr_ses.addrstring);
 		send_msg_userauth_failure(0, 1);
 		goto cleanup;
 	}
+	
+	// ========================== Siklu addition start ===========================
+	char **pam_envlist, **pam_env;
+	// store/export PAM environment in a process environment
+	// create also file in /tmp/web-auth/<user_name> and write pam env variables to the file
+
+	dropbear_log(LOG_NOTICE,"%s() process pid %d, parrent pid %d", __func__,   getpid(),  getppid());
+	if ((pam_envlist = pam_getenvlist(pamHandlep)) != NULL) {  // Siklu
+		for (pam_env = pam_envlist; *pam_env != NULL; ++pam_env) {
+			int rc;
+
+			char* p = strstr(*pam_env, "=");
+			if (p != NULL) {
+				*p = 0;
+				rc = setenv(*pam_env, ++p, 1);
+				dropbear_log(LOG_NOTICE,"%s() current PAM environment - %s, val %s, rc - %d",	__func__, *pam_env, p, rc);
+				free(*pam_env);
+			}
+		}
+		free(pam_envlist);
+	}
+	// ========================== siklu addition end  ===========================
 
 	/* successful authentication */
 	dropbear_log(LOG_NOTICE, "PAM password auth succeeded for '%s' from %s",
diff -uNr -x '*.log' -x '*.sta*' -x '.p*' -x 'Makefile*' dropbear-2016.74.orig/svr-chansession.c dropbear-2016.74.new/svr-chansession.c
--- dropbear-2016.74.orig/svr-chansession.c	2016-07-21 18:17:09.000000000 +0300
+++ dropbear-2016.74.new/svr-chansession.c	2017-02-14 15:50:10.000000000 +0200
@@ -588,7 +588,7 @@
 		dropbear_exit("Out of memory"); /* TODO disconnect */
 	}
 
-	pw = getpwnam(ses.authstate.pw_name);
+	pw = _getpwnam(ses.authstate.pw_name); // Siklu
 	if (!pw)
 		dropbear_exit("getpwnam failed after succeeding previously");
 	pty_setowner(pw, chansess->tty);
@@ -910,7 +910,8 @@
 	 * etc. This is hazardous, so should only be used for debugging. */
 #ifndef DEBUG_VALGRIND
 #ifdef HAVE_CLEARENV
-	clearenv();
+	// clearenv();   // Siklu do not clear environment here. we need to relay all environment as-is
+	// 		with environment received from remote tacacs server to our cli application
 #else /* don't HAVE_CLEARENV */
 	/* Yay for posix. */
 	if (environ) {
